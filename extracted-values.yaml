COMPUTED VALUES:
common:
  exampleValue: common-chart
  global:
    annotations: {}
    createReleaseInfo: true
    elasticsearch:
      auth: {}
      clusterName: elasticsearch
      disableExporter: false
      enabled: true
      external: false
      prefix: zeebe-record
      tls:
        enabled: false
      url:
        host: '{{ .Release.Name }}-elasticsearch'
        port: 9200
        protocol: http
    identity:
      auth:
        connectors:
          clientId: connectors
        console:
          audience: console-api
          clientId: console
          redirectUrl: http://localhost:8080
          wellKnown: https://well-known-uri
        enabled: true
        identity:
          audience: camunda-identity-resource-server
          clientId: identity
          initialClaimName: oid
          redirectUrl: http://localhost:8085
        issuer: ""
        issuerBackendUrl: ""
        jwksUrl: ""
        operate:
          audience: operate-api
          clientId: operate
          redirectUrl: https://camunda.oreedo.co/operate
        optimize:
          audience: optimize-api
          clientId: optimize
          redirectUrl: https://camunda.oreedo.co/optimize
        publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
        tasklist:
          audience: tasklist-api
          clientId: tasklist
          redirectUrl: https://camunda.oreedo.co/tasklist
        tokenUrl: ""
        type: KEYCLOAK
        webModeler:
          clientApiAudience: web-modeler-api
          clientId: web-modeler
          publicApiAudience: web-modeler-public-api
          redirectUrl: http://localhost:8084
        zeebe:
          audience: zeebe-api
          clientId: zeebe
      keycloak:
        auth: {}
        contextPath: /auth
        internal: false
        realm: /realms/camunda-platform
        url: {}
      service: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: ""
    ingress:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      host: camunda.oreedo.co
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    labels:
      app: camunda-platform
    multiregion:
      installationType: normal
      regionId: 0
      regions: 1
    multitenancy:
      enabled: false
    opensearch:
      auth: {}
      aws:
        enabled: false
      enabled: false
      tls:
        enabled: false
      url:
        port: 443
        protocol: https
    testDeprecationFlags:
      existingSecretsMustBeSet: ignore
    zeebeClusterName: '{{ .Release.Name }}-zeebe'
connectors:
  affinity: {}
  command: []
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: ""
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env: []
  envFrom: []
  extraConfiguration: {}
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/connectors-bundle
    tag: 8.5.4
  inbound:
    auth:
      existingSecret: ""
    mode: disabled
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-connectors
  initContainers: []
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/liveness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  logging:
    level:
      io.camunda.connector: ERROR
  metrics:
    prometheus: /actuator/prometheus
  nodeSelector: {}
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  replicas: 1
  resources:
    limits:
      cpu: 2
      memory: 2Gi
    requests:
      cpu: 1
      memory: 1Gi
  service:
    annotations: {}
    serverName: http
    serverPort: 8080
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
console:
  affinity: {}
  command: []
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: ""
  dnsConfig: {}
  dnsPolicy: ""
  enabled: false
  env: []
  envFrom: []
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: registry.camunda.cloud
    repository: console/console-sm
    tag: 8.5.68
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-console
  initContainers: []
  keycloak:
    realm: camunda-platform
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /health/liveness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  logging: {}
  metrics:
    prometheus: /prometheus
  nodeSelector: {}
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  replicas: 1
  resources:
    limits:
      cpu: 2
      memory: 2Gi
    requests:
      cpu: 1
      memory: 1Gi
  service:
    annotations: {}
    managementPort: 9100
    port: 80
    serverName: http
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
elasticsearch:
  clusterDomain: cluster.local
  clusterName: elastic
  common:
    exampleValue: common-chart
    global:
      annotations: {}
      compatibility:
        openshift:
          adaptSecurityContext: auto
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        service:
          name: elasticsearch
          ports:
            restAPI: 9200
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      kibanaEnabled: false
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
  commonAnnotations: {}
  commonLabels: {}
  config: {}
  containerPorts:
    restAPI: 9200
    transport: 9300
  coordinating:
    affinity: {}
    annotations: {}
    args: []
    automountServiceAccountToken: false
    autoscaling:
      enabled: false
      maxReplicas: 11
      minReplicas: 3
      targetCPU: ""
      targetMemory: ""
    command: []
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: {}
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraRoles: []
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    heapSize: 128m
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 180
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: ""
    podLabels: {}
    podManagementPolicy: Parallel
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 0
    resources: {}
    resourcesPreset: small
    schedulerName: ""
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    servicenameOverride: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  data:
    affinity: {}
    annotations: {}
    args: []
    automountServiceAccountToken: false
    autoscaling:
      enabled: false
      maxReplicas: 11
      minReplicas: 3
      targetCPU: ""
      targetMemory: ""
    command: []
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: {}
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraRoles: []
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    heapSize: 1024m
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 180
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: ""
      existingVolume: ""
      selector: {}
      size: 8Gi
      storageClass: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: ""
    podLabels: {}
    podManagementPolicy: Parallel
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 0
    resources: {}
    resourcesPreset: medium
    schedulerName: ""
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    servicenameOverride: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: true
  extraConfig: {}
  extraDeploy: []
  extraEnvVars: []
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraHosts: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global:
    annotations: {}
    compatibility:
      openshift:
        adaptSecurityContext: auto
    createReleaseInfo: true
    elasticsearch:
      auth: {}
      clusterName: elasticsearch
      disableExporter: false
      enabled: true
      external: false
      prefix: zeebe-record
      service:
        name: elasticsearch
        ports:
          restAPI: 9200
      tls:
        enabled: false
      url:
        host: '{{ .Release.Name }}-elasticsearch'
        port: 9200
        protocol: http
    identity:
      auth:
        connectors:
          clientId: connectors
        console:
          audience: console-api
          clientId: console
          redirectUrl: http://localhost:8080
          wellKnown: https://well-known-uri
        enabled: true
        identity:
          audience: camunda-identity-resource-server
          clientId: identity
          initialClaimName: oid
          redirectUrl: http://localhost:8085
        issuer: ""
        issuerBackendUrl: ""
        jwksUrl: ""
        operate:
          audience: operate-api
          clientId: operate
          redirectUrl: https://camunda.oreedo.co/operate
        optimize:
          audience: optimize-api
          clientId: optimize
          redirectUrl: https://camunda.oreedo.co/optimize
        publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
        tasklist:
          audience: tasklist-api
          clientId: tasklist
          redirectUrl: https://camunda.oreedo.co/tasklist
        tokenUrl: ""
        type: KEYCLOAK
        webModeler:
          clientApiAudience: web-modeler-api
          clientId: web-modeler
          publicApiAudience: web-modeler-public-api
          redirectUrl: http://localhost:8084
        zeebe:
          audience: zeebe-api
          clientId: zeebe
      keycloak:
        auth: {}
        contextPath: /auth
        internal: false
        realm: /realms/camunda-platform
        url: {}
      service: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: ""
    imagePullSecrets: []
    imageRegistry: ""
    ingress:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      host: camunda.oreedo.co
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    kibanaEnabled: false
    labels:
      app: camunda-platform
    multiregion:
      installationType: normal
      regionId: 0
      regions: 1
    multitenancy:
      enabled: false
    opensearch:
      auth: {}
      aws:
        enabled: false
      enabled: false
      tls:
        enabled: false
      url:
        port: 443
        protocol: https
    storageClass: ""
    testDeprecationFlags:
      existingSecretsMustBeSet: ignore
    zeebeClusterName: '{{ .Release.Name }}-zeebe'
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/elasticsearch
    tag: 8.12.2
  ingest:
    affinity: {}
    annotations: {}
    args: []
    automountServiceAccountToken: false
    autoscaling:
      enabled: false
      maxReplicas: 11
      minReplicas: 3
      targetCPU: ""
      targetMemory: ""
    command: []
    containerPorts:
      restAPI: 9200
      transport: 9300
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: {}
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraRoles: []
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    heapSize: 128m
    hostAliases: []
    ingress:
      annotations: {}
      apiVersion: ""
      enabled: false
      extraHosts: []
      extraPaths: []
      extraRules: []
      extraTls: []
      hostname: elasticsearch-ingest.local
      ingressClassName: ""
      path: /
      pathType: ImplementationSpecific
      secrets: []
      selfSigned: false
      tls: false
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 180
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: ""
    podLabels: {}
    podManagementPolicy: Parallel
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 2
    resources: {}
    resourcesPreset: small
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      enabled: false
      externalTrafficPolicy: Cluster
      extraPorts: []
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        restAPI: ""
        transport: ""
      ports:
        restAPI: 9200
        transport: 9300
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    servicenameOverride: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  ingress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: elasticsearch.local
    ingressClassName: ""
    path: /
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    tls: false
  initContainers: []
  initScripts: {}
  initScriptsCM: ""
  initScriptsSecret: ""
  kibana:
    affinity: {}
    args: []
    automountServiceAccountToken: false
    clusterDomain: cluster.local
    command: []
    common:
      exampleValue: common-chart
      global:
        annotations: {}
        compatibility:
          openshift:
            adaptSecurityContext: auto
        createReleaseInfo: true
        elasticsearch:
          auth: {}
          clusterName: elasticsearch
          disableExporter: false
          enabled: true
          external: false
          prefix: zeebe-record
          service:
            name: elasticsearch
            ports:
              restAPI: 9200
          tls:
            enabled: false
          url:
            host: '{{ .Release.Name }}-elasticsearch'
            port: 9200
            protocol: http
        identity:
          auth:
            connectors:
              clientId: connectors
            console:
              audience: console-api
              clientId: console
              redirectUrl: http://localhost:8080
              wellKnown: https://well-known-uri
            enabled: true
            identity:
              audience: camunda-identity-resource-server
              clientId: identity
              initialClaimName: oid
              redirectUrl: http://localhost:8085
            issuer: ""
            issuerBackendUrl: ""
            jwksUrl: ""
            operate:
              audience: operate-api
              clientId: operate
              redirectUrl: https://camunda.oreedo.co/operate
            optimize:
              audience: optimize-api
              clientId: optimize
              redirectUrl: https://camunda.oreedo.co/optimize
            publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
            tasklist:
              audience: tasklist-api
              clientId: tasklist
              redirectUrl: https://camunda.oreedo.co/tasklist
            tokenUrl: ""
            type: KEYCLOAK
            webModeler:
              clientApiAudience: web-modeler-api
              clientId: web-modeler
              publicApiAudience: web-modeler-public-api
              redirectUrl: http://localhost:8084
            zeebe:
              audience: zeebe-api
              clientId: zeebe
          keycloak:
            auth: {}
            contextPath: /auth
            internal: false
            realm: /realms/camunda-platform
            url: {}
          service: {}
        image:
          pullPolicy: IfNotPresent
          pullSecrets: []
          registry: ""
        imagePullSecrets: []
        imageRegistry: ""
        ingress:
          annotations:
            ingress.kubernetes.io/rewrite-target: /
            nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
            nginx.ingress.kubernetes.io/ssl-redirect: "false"
          className: public
          enabled: true
          host: camunda.oreedo.co
          pathType: Prefix
          tls:
            enabled: true
            secretName: oreedo-co-tls
        kibanaEnabled: false
        labels:
          app: camunda-platform
        multiregion:
          installationType: normal
          regionId: 0
          regions: 1
        multitenancy:
          enabled: false
        opensearch:
          auth: {}
          aws:
            enabled: false
          enabled: false
          tls:
            enabled: false
          url:
            port: 443
            protocol: https
        storageClass: ""
        testDeprecationFlags:
          existingSecretsMustBeSet: ignore
        zeebeClusterName: '{{ .Release.Name }}-zeebe'
    commonAnnotations: {}
    commonLabels: {}
    configuration:
      server:
        basePath: ""
        rewriteBasePath: false
    configurationCM: ""
    containerPorts:
      http: 5601
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: false
      runAsGroup: 0
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    elasticsearch:
      hosts:
      - '{{ include "elasticsearch.service.name" . }}'
      port: '{{ include "elasticsearch.service.ports.restAPI" . }}'
      security:
        auth:
          createSystemUser: false
          elasticsearchPasswordSecret: ""
          enabled: false
          existingSecret: ""
          kibanaPassword: ""
        tls:
          enabled: false
          existingSecret: ""
          passwordsSecret: ""
          truststorePassword: ""
          usePemCerts: false
          verificationMode: full
    extraConfiguration: {}
    extraDeploy: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    forceInitScripts: false
    fullnameOverride: ""
    global:
      annotations: {}
      compatibility:
        openshift:
          adaptSecurityContext: auto
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        service:
          name: elasticsearch
          ports:
            restAPI: 9200
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      kibanaEnabled: false
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
    hostAliases: []
    image:
      debug: false
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/kibana
      tag: 8.12.2-debian-12-r1
    ingress:
      annotations: {}
      apiVersion: ""
      enabled: false
      extraHosts: []
      extraPaths: []
      extraRules: []
      extraTls: []
      hostname: kibana.local
      ingressClassName: ""
      path: /
      pathType: ImplementationSpecific
      secrets: []
      selfSigned: false
      tls: false
    initContainers: []
    initScriptsCM: ""
    initScriptsSecret: ""
    kubeVersion: ""
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 120
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    metrics:
      enabled: false
      service:
        annotations:
          prometheus.io/path: _prometheus/metrics
          prometheus.io/port: "80"
          prometheus.io/scrape: "true"
      serviceMonitor:
        enabled: false
        honorLabels: false
        interval: ""
        jobLabel: ""
        labels: {}
        metricRelabelings: []
        namespace: ""
        relabelings: []
        scrapeTimeout: ""
        selector: {}
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataSource: {}
      enabled: true
      existingClaim: ""
      selector: {}
      size: 10Gi
      storageClass: ""
      subPath: ""
    plugins: []
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources: {}
    resourcesPreset: none
    savedObjects:
      configmap: ""
      urls: []
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      extraPorts: []
      labels: {}
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        http: ""
      ports:
        http: 5601
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 6
      initialDelaySeconds: 120
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tls:
      autoGenerated: false
      enabled: false
      existingSecret: ""
      keyPassword: ""
      keystorePassword: ""
      passwordsSecret: ""
      usePemCerts: false
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
    volumePermissions:
      enabled: false
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/os-shell
        tag: 12-debian-12-r16
      resources: {}
      resourcesPreset: none
  kubeVersion: ""
  master:
    affinity: {}
    annotations: {}
    args: []
    automountServiceAccountToken: false
    autoscaling:
      enabled: false
      maxReplicas: 11
      minReplicas: 3
      targetCPU: ""
      targetMemory: ""
    command: []
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: {}
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extraEnvVars:
    - name: ELASTICSEARCH_ENABLE_REST_TLS
      value: "false"
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraRoles: []
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    heapSize: 1024m
    hostAliases: []
    initContainers: []
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 180
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    masterOnly: false
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    pdb:
      create: false
      maxUnavailable: ""
      minAvailable: 1
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: ""
      existingVolume: ""
      selector: {}
      size: 15Gi
      storageClass: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: ""
    podLabels: {}
    podManagementPolicy: Parallel
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits:
        cpu: 2
        memory: 2Gi
      requests:
        cpu: 1
        memory: 2Gi
    resourcesPreset: small
    schedulerName: ""
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    servicenameOverride: ""
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 90
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      type: RollingUpdate
  metrics:
    affinity: {}
    annotations:
      helm.sh/hook: post-install,post-upgrade
      helm.sh/hook-weight: "5"
    args: []
    automountServiceAccountToken: false
    command: []
    containerPorts:
      http: 9114
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
      seLinuxOptions: {}
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraArgs: []
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    fullnameOverride: ""
    hostAliases: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/elasticsearch-exporter
      tag: 1.7.0-debian-12-r14
    initContainers: []
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 60
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    nameOverride: ""
    networkPolicy:
      allowExternal: true
      allowExternalEgress: true
      enabled: true
      extraEgress: []
      extraIngress: []
      ingressNSMatchLabels: {}
      ingressNSPodMatchLabels: {}
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    podAffinityPreset: ""
    podAnnotations:
      prometheus.io/port: "9114"
      prometheus.io/scrape: "true"
    podAntiAffinityPreset: ""
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    priorityClassName: ""
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    resources: {}
    resourcesPreset: nano
    schedulerName: ""
    service:
      annotations:
        prometheus.io/port: "9114"
        prometheus.io/scrape: "true"
      port: 9114
      type: ClusterIP
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    tolerations: []
    topologySpreadConstraints: []
  nameOverride: ""
  namespaceOverride: ""
  plugins: ""
  security:
    elasticPassword: ""
    enabled: false
    existingSecret: ""
    fipsMode: false
    tls:
      autoGenerated: false
      coordinating:
        existingSecret: ""
      data:
        existingSecret: ""
      ingest:
        existingSecret: ""
      keyPassword: ""
      keystoreFilename: elasticsearch.keystore.jks
      keystorePassword: ""
      master:
        existingSecret: ""
      passwordsSecret: ""
      restEncryption: true
      secretKey: ""
      secretKeystoreKey: ""
      secretTruststoreKey: ""
      truststoreFilename: elasticsearch.truststore.jks
      truststorePassword: ""
      usePemCerts: false
      verificationMode: full
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraPorts: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      restAPI: ""
      transport: ""
    ports:
      restAPI: 9200
      transport: 9300
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  sidecars: []
  snapshotRepoPath: ""
  sysctlImage:
    digest: ""
    enabled: true
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/os-shell
    resources: {}
    resourcesPreset: nano
    tag: 12-debian-12-r18
  useIstioLabels: true
  volumePermissions:
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/os-shell
      tag: 12-debian-12-r18
    resources: {}
    resourcesPreset: nano
global:
  annotations: {}
  createReleaseInfo: true
  elasticsearch:
    auth: {}
    clusterName: elasticsearch
    disableExporter: false
    enabled: true
    external: false
    prefix: zeebe-record
    tls:
      enabled: false
    url:
      host: '{{ .Release.Name }}-elasticsearch'
      port: 9200
      protocol: http
  identity:
    auth:
      connectors:
        clientId: connectors
      console:
        audience: console-api
        clientId: console
        redirectUrl: http://localhost:8080
        wellKnown: https://well-known-uri
      enabled: true
      identity:
        audience: camunda-identity-resource-server
        clientId: identity
        initialClaimName: oid
        redirectUrl: http://localhost:8085
      issuer: ""
      issuerBackendUrl: ""
      jwksUrl: ""
      operate:
        audience: operate-api
        clientId: operate
        redirectUrl: https://camunda.oreedo.co/operate
      optimize:
        audience: optimize-api
        clientId: optimize
        redirectUrl: https://camunda.oreedo.co/optimize
      publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
      tasklist:
        audience: tasklist-api
        clientId: tasklist
        redirectUrl: https://camunda.oreedo.co/tasklist
      tokenUrl: ""
      type: KEYCLOAK
      webModeler:
        clientApiAudience: web-modeler-api
        clientId: web-modeler
        publicApiAudience: web-modeler-public-api
        redirectUrl: http://localhost:8084
      zeebe:
        audience: zeebe-api
        clientId: zeebe
    keycloak:
      auth: {}
      contextPath: /auth
      internal: false
      realm: /realms/camunda-platform
      url: {}
    service: {}
  image:
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: ""
    tag: null
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: public
    enabled: true
    host: camunda.oreedo.co
    pathType: Prefix
    tls:
      enabled: true
      secretName: oreedo-co-tls
  labels:
    app: camunda-platform
  multiregion:
    installationType: normal
    regionId: 0
    regions: 1
  multitenancy:
    enabled: false
  opensearch:
    auth: {}
    aws:
      enabled: false
    enabled: false
    tls:
      enabled: false
    url:
      port: 443
      protocol: https
  testDeprecationFlags:
    existingSecretsMustBeSet: ignore
  zeebeClusterName: '{{ .Release.Name }}-zeebe'
identity:
  affinity: {}
  command: []
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: /identity
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env: []
  envFrom: []
  externalDatabase:
    database: null
    enabled: false
    existingSecret: null
    existingSecretPasswordKey: null
    host: null
    password: null
    port: null
    username: null
  extraConfiguration: {}
  extraVolumeMounts: []
  extraVolumes: []
  firstUser:
    email: demo@example.org
    enabled: true
    existingSecret: ""
    firstName: Demo
    lastName: User
    password: demo
    username: demo
  fullURL: https://camunda.oreedo.co/identity
  fullnameOverride: ""
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/identity
    tag: 8.5.3
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-identity
  initContainers: []
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  metrics:
    prometheus: /actuator/prometheus
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 600m
      memory: 400Mi
  service:
    annotations: {}
    metricsName: metrics
    metricsPort: 82
    port: 80
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
identityKeycloak:
  adminIngress:
    annotations: {}
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: keycloak.local
    ingressClassName: ""
    labels: {}
    path: '{{ .Values.httpRelativePath }}'
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    servicePort: http
    tls: false
  affinity: {}
  args: []
  auth:
    adminPassword: ""
    adminUser: admin
    annotations: {}
    existingSecret: ""
    passwordSecretKey: ""
  automountServiceAccountToken: true
  autoscaling:
    enabled: false
    maxReplicas: 11
    minReplicas: 1
    targetCPU: ""
    targetMemory: ""
  cache:
    enabled: true
    stackFile: ""
    stackName: kubernetes
  clusterDomain: cluster.local
  command: []
  common:
    exampleValue: common-chart
    global:
      annotations: {}
      compatibility:
        openshift:
          adaptSecurityContext: disabled
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
  commonAnnotations: {}
  commonLabels: {}
  configuration: ""
  containerPorts:
    http: 8080
    https: 8443
    infinispan: 7800
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    enabled: true
    privileged: false
    readOnlyRootFilesystem: true
    runAsGroup: 0
    runAsNonRoot: true
    runAsUser: 1001
    seLinuxOptions: null
    seccompProfile:
      type: RuntimeDefault
  customLivenessProbe: {}
  customReadinessProbe: {}
  customStartupProbe: {}
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  dnsConfig: {}
  dnsPolicy: ""
  enableDefaultInitContainers: true
  enableServiceLinks: true
  enabled: true
  existingConfigmap: ""
  externalDatabase:
    annotations: {}
    database: bitnami_keycloak
    existingSecret: ""
    existingSecretDatabaseKey: ""
    existingSecretHostKey: ""
    existingSecretPasswordKey: ""
    existingSecretPortKey: ""
    existingSecretUserKey: ""
    host: ""
    password: ""
    port: 5432
    user: bn_keycloak
  extraContainerPorts: []
  extraDeploy: []
  extraEnvVars:
  - name: KEYCLOAK_PROXY_ADDRESS_FORWARDING
    value: '{{ .Values.global.ingress.tls.enabled }}'
  extraEnvVarsCM: ""
  extraEnvVarsSecret: ""
  extraStartupArgs: ""
  extraVolumeMounts:
  - mountPath: /opt/bitnami/keycloak/themes/identity
    name: camunda-theme
  - mountPath: /opt/bitnami/keycloak/data/tmp
    name: data-tmp
  extraVolumes:
  - emptyDir: {}
    name: data-tmp
  - emptyDir:
      sizeLimit: 10Mi
    name: camunda-theme
  fullnameOverride: ""
  global:
    annotations: {}
    compatibility:
      openshift:
        adaptSecurityContext: disabled
    createReleaseInfo: true
    elasticsearch:
      auth: {}
      clusterName: elasticsearch
      disableExporter: false
      enabled: true
      external: false
      prefix: zeebe-record
      tls:
        enabled: false
      url:
        host: '{{ .Release.Name }}-elasticsearch'
        port: 9200
        protocol: http
    identity:
      auth:
        connectors:
          clientId: connectors
        console:
          audience: console-api
          clientId: console
          redirectUrl: http://localhost:8080
          wellKnown: https://well-known-uri
        enabled: true
        identity:
          audience: camunda-identity-resource-server
          clientId: identity
          initialClaimName: oid
          redirectUrl: http://localhost:8085
        issuer: ""
        issuerBackendUrl: ""
        jwksUrl: ""
        operate:
          audience: operate-api
          clientId: operate
          redirectUrl: https://camunda.oreedo.co/operate
        optimize:
          audience: optimize-api
          clientId: optimize
          redirectUrl: https://camunda.oreedo.co/optimize
        publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
        tasklist:
          audience: tasklist-api
          clientId: tasklist
          redirectUrl: https://camunda.oreedo.co/tasklist
        tokenUrl: ""
        type: KEYCLOAK
        webModeler:
          clientApiAudience: web-modeler-api
          clientId: web-modeler
          publicApiAudience: web-modeler-public-api
          redirectUrl: http://localhost:8084
        zeebe:
          audience: zeebe-api
          clientId: zeebe
      keycloak:
        auth: {}
        contextPath: /auth
        internal: false
        realm: /realms/camunda-platform
        url: {}
      service: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: ""
    imagePullSecrets: []
    imageRegistry: ""
    ingress:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      host: camunda.oreedo.co
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    labels:
      app: camunda-platform
    multiregion:
      installationType: normal
      regionId: 0
      regions: 1
    multitenancy:
      enabled: false
    opensearch:
      auth: {}
      aws:
        enabled: false
      enabled: false
      tls:
        enabled: false
      url:
        port: 443
        protocol: https
    storageClass: ""
    testDeprecationFlags:
      existingSecretsMustBeSet: ignore
    zeebeClusterName: '{{ .Release.Name }}-zeebe'
  hostAliases: []
  httpRelativePath: /auth/
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/keycloak
    tag: 23.0.7
  ingress:
    annotations:
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
    apiVersion: ""
    enabled: false
    extraHosts: []
    extraPaths: []
    extraRules: []
    extraTls: []
    hostname: keycloak.local
    ingressClassName: ""
    labels: {}
    path: '{{ .Values.httpRelativePath }}'
    pathType: ImplementationSpecific
    secrets: []
    selfSigned: false
    servicePort: http
    tls: false
  initContainers:
  - command:
    - sh
    - -c
    - cp -a /app/keycloak-theme/* /mnt
    image: '{{ .Values.global.identity.image | default "camunda/identity:latest" }}'
    imagePullPolicy: '{{ .Values.global.identity.imagePullPolicy | default "Always"
      }}'
    name: copy-camunda-theme
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    volumeMounts:
    - mountPath: /mnt
      name: camunda-theme
  initdbScripts: {}
  initdbScriptsConfigMap: ""
  keycloakConfigCli:
    annotations:
      helm.sh/hook: post-install,post-upgrade,post-rollback
      helm.sh/hook-delete-policy: hook-succeeded,before-hook-creation
      helm.sh/hook-weight: "5"
    args: []
    automountServiceAccountToken: true
    backoffLimit: 1
    cleanupAfterFinished:
      enabled: false
      seconds: 600
    command: []
    configuration: {}
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: false
      runAsGroup: 0
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    enabled: false
    existingConfigmap: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/keycloak-config-cli
      tag: 5.11.1-debian-12-r0
    initContainers: []
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      fsGroupChangePolicy: Always
      supplementalGroups: []
      sysctls: []
    podTolerations: []
    resources: {}
    resourcesPreset: none
    sidecars: []
  kubeVersion: ""
  lifecycleHooks: {}
  livenessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 300
    periodSeconds: 1
    successThreshold: 1
    timeoutSeconds: 5
  logging:
    level: INFO
    output: default
  metrics:
    enabled: false
    prometheusRule:
      enabled: false
      groups: []
      labels: {}
      namespace: ""
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.ports.http }}'
        prometheus.io/scrape: "true"
      extraPorts: []
      ports:
        http: 8080
    serviceMonitor:
      enabled: false
      endpoints:
      - path: '{{ include "keycloak.httpPath" . }}metrics'
      - path: '{{ include "keycloak.httpPath" . }}realms/master/metrics'
      honorLabels: false
      interval: 30s
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      path: ""
      port: http
      relabelings: []
      scrapeTimeout: ""
      selector: {}
  nameOverride: keycloak
  namespaceOverride: ""
  networkPolicy:
    allowExternal: true
    allowExternalEgress: true
    enabled: true
    extraEgress: []
    extraIngress: []
    ingressNSMatchLabels: {}
    ingressNSPodMatchLabels: {}
    kubeAPIServerPorts:
    - 443
    - 6443
    - 8443
  nodeAffinityPreset:
    key: ""
    type: ""
    values: []
  nodeSelector: {}
  pdb:
    create: false
    maxUnavailable: ""
    minAvailable: 1
  podAffinityPreset: ""
  podAnnotations: {}
  podAntiAffinityPreset: soft
  podLabels: {}
  podManagementPolicy: Parallel
  podSecurityContext:
    enabled: true
    fsGroup: 1001
    fsGroupChangePolicy: Always
    runAsNonRoot: true
    supplementalGroups: []
    sysctls: []
  postgresql:
    architecture: standalone
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    auth:
      database: bitnami_keycloak
      enablePostgresUser: true
      existingSecret: ""
      password: ""
      postgresPassword: ""
      replicationPassword: ""
      replicationUsername: repl_user
      secretKeys:
        adminPasswordKey: postgres-password
        replicationPasswordKey: replication-password
        userPasswordKey: password
      usePasswordFiles: false
      username: bn_keycloak
    backup:
      cronjob:
        annotations: {}
        command:
        - /bin/sh
        - -c
        - pg_dumpall --clean --if-exists --load-via-partition-root --quote-all-identifiers
          --no-password --file=${PGDUMP_DIR}/pg_dumpall-$(date '+%Y-%m-%d-%H-%M').pgdump
        concurrencyPolicy: Allow
        containerSecurityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          enabled: true
          privileged: false
          readOnlyRootFilesystem: false
          runAsGroup: 0
          runAsNonRoot: true
          runAsUser: 1001
          seccompProfile:
            type: RuntimeDefault
        failedJobsHistoryLimit: 1
        labels: {}
        nodeSelector: {}
        podSecurityContext:
          enabled: true
          fsGroup: 1001
          fsGroupChangePolicy: Always
          supplementalGroups: []
          sysctls: []
        resources: {}
        resourcesPreset: none
        restartPolicy: OnFailure
        schedule: '@daily'
        startingDeadlineSeconds: ""
        storage:
          accessModes:
          - ReadWriteOnce
          annotations: {}
          existingClaim: ""
          mountPath: /backup/pgdump
          resourcePolicy: ""
          size: 8Gi
          storageClass: ""
          subPath: ""
          volumeClaimTemplates:
            selector: {}
        successfulJobsHistoryLimit: 3
        timeZone: ""
        ttlSecondsAfterFinished: ""
      enabled: false
    clusterDomain: cluster.local
    common:
      exampleValue: common-chart
      global:
        annotations: {}
        compatibility:
          openshift:
            adaptSecurityContext: disabled
        createReleaseInfo: true
        elasticsearch:
          auth: {}
          clusterName: elasticsearch
          disableExporter: false
          enabled: true
          external: false
          prefix: zeebe-record
          tls:
            enabled: false
          url:
            host: '{{ .Release.Name }}-elasticsearch'
            port: 9200
            protocol: http
        identity:
          auth:
            connectors:
              clientId: connectors
            console:
              audience: console-api
              clientId: console
              redirectUrl: http://localhost:8080
              wellKnown: https://well-known-uri
            enabled: true
            identity:
              audience: camunda-identity-resource-server
              clientId: identity
              initialClaimName: oid
              redirectUrl: http://localhost:8085
            issuer: ""
            issuerBackendUrl: ""
            jwksUrl: ""
            operate:
              audience: operate-api
              clientId: operate
              redirectUrl: https://camunda.oreedo.co/operate
            optimize:
              audience: optimize-api
              clientId: optimize
              redirectUrl: https://camunda.oreedo.co/optimize
            publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
            tasklist:
              audience: tasklist-api
              clientId: tasklist
              redirectUrl: https://camunda.oreedo.co/tasklist
            tokenUrl: ""
            type: KEYCLOAK
            webModeler:
              clientApiAudience: web-modeler-api
              clientId: web-modeler
              publicApiAudience: web-modeler-public-api
              redirectUrl: http://localhost:8084
            zeebe:
              audience: zeebe-api
              clientId: zeebe
          keycloak:
            auth: {}
            contextPath: /auth
            internal: false
            realm: /realms/camunda-platform
            url: {}
          service: {}
        image:
          pullPolicy: IfNotPresent
          pullSecrets: []
          registry: ""
          tag: null
        imagePullSecrets: []
        imageRegistry: ""
        ingress:
          annotations:
            ingress.kubernetes.io/rewrite-target: /
            nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
            nginx.ingress.kubernetes.io/ssl-redirect: "false"
          className: public
          enabled: true
          host: camunda.oreedo.co
          pathType: Prefix
          tls:
            enabled: true
            secretName: oreedo-co-tls
        labels:
          app: camunda-platform
        multiregion:
          installationType: normal
          regionId: 0
          regions: 1
        multitenancy:
          enabled: false
        opensearch:
          auth: {}
          aws:
            enabled: false
          enabled: false
          tls:
            enabled: false
          url:
            port: 443
            protocol: https
        postgresql:
          auth:
            database: ""
            existingSecret: ""
            password: ""
            postgresPassword: ""
            secretKeys:
              adminPasswordKey: ""
              replicationPasswordKey: ""
              userPasswordKey: ""
            username: ""
          service:
            ports:
              postgresql: ""
        storageClass: ""
        testDeprecationFlags:
          existingSecretsMustBeSet: ignore
        zeebeClusterName: '{{ .Release.Name }}-zeebe'
    commonAnnotations: {}
    commonLabels: {}
    containerPorts:
      postgresql: 5432
    diagnosticMode:
      args:
      - infinity
      command:
      - sleep
      enabled: false
    enabled: true
    extraDeploy: []
    fullnameOverride: ""
    global:
      annotations: {}
      compatibility:
        openshift:
          adaptSecurityContext: disabled
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      postgresql:
        auth:
          database: ""
          existingSecret: ""
          password: ""
          postgresPassword: ""
          secretKeys:
            adminPasswordKey: ""
            replicationPasswordKey: ""
            userPasswordKey: ""
          username: ""
        service:
          ports:
            postgresql: ""
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
    image:
      debug: false
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgresql
      tag: 15.7.0
    kubeVersion: ""
    ldap:
      basedn: ""
      binddn: ""
      bindpw: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      searchAttribute: ""
      searchFilter: ""
      server: ""
      suffix: ""
      tls:
        enabled: false
      uri: ""
    metrics:
      collectors: {}
      containerPorts:
        metrics: 9187
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        enabled: true
        privileged: false
        readOnlyRootFilesystem: false
        runAsGroup: 0
        runAsNonRoot: true
        runAsUser: 1001
        seccompProfile:
          type: RuntimeDefault
      customLivenessProbe: {}
      customMetrics: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      enabled: false
      extraEnvVars: []
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.15.0-debian-12-r14
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        enabled: false
        labels: {}
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources: {}
      resourcesPreset: none
      service:
        annotations:
          prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
          prometheus.io/scrape: "true"
        clusterIP: ""
        ports:
          metrics: 9187
        sessionAffinity: None
      serviceMonitor:
        enabled: false
        honorLabels: false
        interval: ""
        jobLabel: ""
        labels: {}
        metricRelabelings: []
        namespace: ""
        relabelings: []
        scrapeTimeout: ""
        selector: {}
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 10
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
    nameOverride: ""
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlSharedPreloadLibraries: pgaudit
    primary:
      affinity: {}
      annotations: {}
      args: []
      automountServiceAccountToken: false
      command: []
      configuration: ""
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        enabled: true
        privileged: false
        readOnlyRootFilesystem: true
        runAsGroup: 0
        runAsNonRoot: true
        runAsUser: 1001
        seLinuxOptions: null
        seccompProfile:
          type: RuntimeDefault
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      existingConfigmap: ""
      existingExtendedConfigmap: ""
      extendedConfiguration: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      initdb:
        args: ""
        password: ""
        postgresqlWalDir: ""
        scripts: {}
        scriptsConfigMap: ""
        scriptsSecret: ""
        user: ""
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      name: primary
      networkPolicy:
        allowExternal: true
        allowExternalEgress: true
        enabled: true
        extraEgress: []
        extraIngress: []
        ingressNSMatchLabels: {}
        ingressNSPodMatchLabels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        labels: {}
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      persistentVolumeClaimRetentionPolicy:
        enabled: false
        whenDeleted: Retain
        whenScaled: Retain
      pgHbaConfiguration: ""
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
        fsGroupChangePolicy: Always
        runAsNonRoot: true
        supplementalGroups: []
        sysctls: []
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources: {}
      resourcesPreset: none
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        headless:
          annotations: {}
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      standby:
        enabled: false
        primaryHost: ""
        primaryPort: ""
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    psp:
      create: false
    rbac:
      create: false
      rules: []
    readReplicas:
      affinity: {}
      annotations: {}
      args: []
      automountServiceAccountToken: false
      command: []
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        enabled: true
        privileged: false
        readOnlyRootFilesystem: false
        runAsGroup: 0
        runAsNonRoot: true
        runAsUser: 1001
        seccompProfile:
          type: RuntimeDefault
      customLivenessProbe: {}
      customReadinessProbe: {}
      customStartupProbe: {}
      extendedConfiguration: ""
      extraEnvVars: []
      extraEnvVarsCM: ""
      extraEnvVarsSecret: ""
      extraPodSpec: {}
      extraVolumeMounts: []
      extraVolumes: []
      hostAliases: []
      hostIPC: false
      hostNetwork: false
      initContainers: []
      labels: {}
      lifecycleHooks: {}
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      name: read
      networkPolicy:
        allowExternal: true
        allowExternalEgress: true
        enabled: true
        extraEgress: []
        extraIngress: []
        ingressNSMatchLabels: {}
        ingressNSPodMatchLabels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        dataSource: {}
        enabled: true
        existingClaim: ""
        labels: {}
        mountPath: /bitnami/postgresql
        selector: {}
        size: 8Gi
        storageClass: ""
        subPath: ""
      persistentVolumeClaimRetentionPolicy:
        enabled: false
        whenDeleted: Retain
        whenScaled: Retain
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
        fsGroupChangePolicy: Always
        supplementalGroups: []
        sysctls: []
      priorityClassName: ""
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      replicaCount: 1
      resources: {}
      resourcesPreset: none
      schedulerName: ""
      service:
        annotations: {}
        clusterIP: ""
        externalTrafficPolicy: Cluster
        extraPorts: []
        headless:
          annotations: {}
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        nodePorts:
          postgresql: ""
        ports:
          postgresql: 5432
        sessionAffinity: None
        sessionAffinityConfig: {}
        type: ClusterIP
      sidecars: []
      startupProbe:
        enabled: false
        failureThreshold: 15
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      terminationGracePeriodSeconds: ""
      tolerations: []
      topologySpreadConstraints: []
      updateStrategy:
        rollingUpdate: {}
        type: RollingUpdate
    replication:
      applicationName: my_application
      numSynchronousReplicas: 0
      synchronousCommit: "off"
    serviceAccount:
      annotations: {}
      automountServiceAccountToken: false
      create: true
      name: ""
    serviceBindings:
      enabled: false
    shmVolume:
      enabled: true
      sizeLimit: ""
    tls:
      autoGenerated: false
      certCAFilename: ""
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: ""
      enabled: false
      preferServerCiphers: true
    volumePermissions:
      containerSecurityContext:
        runAsGroup: 0
        runAsNonRoot: false
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault
      enabled: false
      image:
        digest: ""
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/os-shell
        tag: 12-debian-12-r16
      resources: {}
      resourcesPreset: none
  priorityClassName: ""
  production: false
  proxy: edge
  rbac:
    create: false
    rules: []
  readinessProbe:
    enabled: true
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  replicaCount: 1
  resources: {}
  resourcesPreset: none
  revisionHistoryLimitCount: 10
  schedulerName: ""
  service:
    annotations: {}
    clusterIP: ""
    externalTrafficPolicy: Cluster
    extraHeadlessPorts: []
    extraPorts: []
    headless:
      annotations: {}
      extraPorts: []
    http:
      enabled: true
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    nodePorts:
      http: ""
      https: ""
    ports:
      http: 80
      https: 443
    sessionAffinity: None
    sessionAffinityConfig: {}
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    create: true
    extraLabels: {}
    name: ""
  sidecars: []
  spi:
    existingSecret: ""
    hostnameVerificationPolicy: ""
    passwordsSecret: ""
    truststoreFilename: keycloak-spi.truststore.jks
    truststorePassword: ""
  startupProbe:
    enabled: false
    failureThreshold: 60
    initialDelaySeconds: 30
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 1
  statefulsetAnnotations: {}
  terminationGracePeriodSeconds: ""
  tls:
    autoGenerated: false
    enabled: false
    existingSecret: ""
    keystoreFilename: keycloak.keystore.jks
    keystorePassword: ""
    passwordsSecret: ""
    truststoreFilename: keycloak.truststore.jks
    truststorePassword: ""
    usePem: false
  tolerations: []
  topologySpreadConstraints: []
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
identityPostgresql:
  architecture: standalone
  audit:
    clientMinMessages: error
    logConnections: false
    logDisconnections: false
    logHostname: false
    logLinePrefix: ""
    logTimezone: ""
    pgAuditLog: ""
    pgAuditLogCatalog: "off"
  auth:
    database: identity
    enablePostgresUser: true
    postgresPassword: ""
    replicationPassword: ""
    replicationUsername: repl_user
    secretKeys:
      adminPasswordKey: postgres-password
      replicationPasswordKey: replication-password
      userPasswordKey: password
    usePasswordFiles: false
    username: identity
  backup:
    cronjob:
      annotations: {}
      command:
      - /bin/sh
      - -c
      - pg_dumpall --clean --if-exists --load-via-partition-root --quote-all-identifiers
        --no-password --file=${PGDUMP_DIR}/pg_dumpall-$(date '+%Y-%m-%d-%H-%M').pgdump
      concurrencyPolicy: Allow
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
        runAsGroup: 0
        runAsNonRoot: true
        runAsUser: 1001
        seccompProfile:
          type: RuntimeDefault
      failedJobsHistoryLimit: 1
      labels: {}
      nodeSelector: {}
      podSecurityContext:
        enabled: true
        fsGroup: 1001
      restartPolicy: OnFailure
      schedule: '@daily'
      startingDeadlineSeconds: ""
      storage:
        accessModes:
        - ReadWriteOnce
        annotations: {}
        existingClaim: ""
        mountPath: /backup/pgdump
        resourcePolicy: ""
        size: 8Gi
        storageClass: ""
        subPath: ""
        volumeClaimTemplates:
          selector: {}
      successfulJobsHistoryLimit: 3
      ttlSecondsAfterFinished: ""
    enabled: false
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global:
      annotations: {}
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
        tag: null
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      postgresql:
        auth:
          database: ""
          existingSecret: ""
          password: ""
          postgresPassword: ""
          secretKeys:
            adminPasswordKey: ""
            replicationPasswordKey: ""
            userPasswordKey: ""
          username: ""
        service:
          ports:
            postgresql: ""
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
  commonAnnotations: {}
  commonLabels: {}
  containerPorts:
    postgresql: 5432
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  extraDeploy: []
  fullnameOverride: ""
  global:
    annotations: {}
    createReleaseInfo: true
    elasticsearch:
      auth: {}
      clusterName: elasticsearch
      disableExporter: false
      enabled: true
      external: false
      prefix: zeebe-record
      tls:
        enabled: false
      url:
        host: '{{ .Release.Name }}-elasticsearch'
        port: 9200
        protocol: http
    identity:
      auth:
        connectors:
          clientId: connectors
        console:
          audience: console-api
          clientId: console
          redirectUrl: http://localhost:8080
          wellKnown: https://well-known-uri
        enabled: true
        identity:
          audience: camunda-identity-resource-server
          clientId: identity
          initialClaimName: oid
          redirectUrl: http://localhost:8085
        issuer: ""
        issuerBackendUrl: ""
        jwksUrl: ""
        operate:
          audience: operate-api
          clientId: operate
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/operate
        optimize:
          audience: optimize-api
          clientId: optimize
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/optimize
        publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
        tasklist:
          audience: tasklist-api
          clientId: tasklist
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/tasklist
        tokenUrl: ""
        type: KEYCLOAK
        webModeler:
          clientApiAudience: web-modeler-api
          clientId: web-modeler
          publicApiAudience: web-modeler-public-api
          redirectUrl: http://localhost:8084
        zeebe:
          audience: zeebe-api
          clientId: zeebe
      keycloak:
        auth: {}
        contextPath: /auth
        internal: false
        realm: /realms/camunda-platform
        url: {}
      service: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: ""
      tag: null
    imagePullSecrets: []
    imageRegistry: ""
    ingress:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      host: camunda.oreedo.co
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    labels:
      app: camunda-platform
    multiregion:
      installationType: normal
      regionId: 0
      regions: 1
    multitenancy:
      enabled: false
    opensearch:
      auth: {}
      aws:
        enabled: false
      enabled: false
      tls:
        enabled: false
      url:
        port: 443
        protocol: https
    postgresql:
      auth:
        database: ""
        existingSecret: ""
        password: ""
        postgresPassword: ""
        secretKeys:
          adminPasswordKey: ""
          replicationPasswordKey: ""
          userPasswordKey: ""
        username: ""
      service:
        ports:
          postgresql: ""
    storageClass: ""
    testDeprecationFlags:
      existingSecretsMustBeSet: ignore
    zeebeClusterName: '{{ .Release.Name }}-zeebe'
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/postgresql
    tag: 15.7.0
  kubeVersion: ""
  ldap:
    basedn: ""
    binddn: ""
    bindpw: ""
    enabled: false
    port: ""
    prefix: ""
    scheme: ""
    searchAttribute: ""
    searchFilter: ""
    server: ""
    suffix: ""
    tls:
      enabled: false
    uri: ""
  metrics:
    containerPorts:
      metrics: 9187
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      runAsGroup: 0
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customMetrics: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraEnvVars: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgres-exporter
      tag: 0.14.0-debian-11-r2
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    prometheusRule:
      enabled: false
      labels: {}
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    resources:
      limits: {}
      requests: {}
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
        prometheus.io/scrape: "true"
      clusterIP: ""
      ports:
        metrics: 9187
      sessionAffinity: None
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
  nameOverride: identity-postgresql
  networkPolicy:
    egressRules:
      customRules: []
      denyConnectionsToExternal: false
    enabled: false
    ingressRules:
      primaryAccessOnlyFrom:
        customRules: []
        enabled: false
        namespaceSelector: {}
        podSelector: {}
      readReplicasAccessOnlyFrom:
        customRules: []
        enabled: false
        namespaceSelector: {}
        podSelector: {}
    metrics:
      enabled: false
      namespaceSelector: {}
      podSelector: {}
  postgresqlDataDir: /bitnami/postgresql/data
  postgresqlSharedPreloadLibraries: pgaudit
  primary:
    affinity: {}
    annotations: {}
    args: []
    command: []
    configuration: ""
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      runAsGroup: 0
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    existingConfigmap: ""
    existingExtendedConfigmap: ""
    extendedConfiguration: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraPodSpec: {}
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    hostIPC: false
    hostNetwork: false
    initContainers: []
    initdb:
      args: ""
      password: ""
      postgresqlWalDir: ""
      scripts: {}
      scriptsConfigMap: ""
      scriptsSecret: ""
      user: ""
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    name: primary
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataSource: {}
      enabled: true
      existingClaim: ""
      labels: {}
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    persistentVolumeClaimRetentionPolicy:
      enabled: false
      whenDeleted: Retain
      whenScaled: Retain
    pgHbaConfiguration: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    resources:
      limits: {}
      requests:
        cpu: 250m
        memory: 256Mi
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      extraPorts: []
      headless:
        annotations: {}
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        postgresql: ""
      ports:
        postgresql: 5432
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    sidecars: []
    standby:
      enabled: false
      primaryHost: ""
      primaryPort: ""
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  psp:
    create: false
  rbac:
    create: false
    rules: []
  readReplicas:
    affinity: {}
    annotations: {}
    args: []
    command: []
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      runAsGroup: 0
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extendedConfiguration: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraPodSpec: {}
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    hostIPC: false
    hostNetwork: false
    initContainers: []
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    name: read
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataSource: {}
      enabled: true
      existingClaim: ""
      labels: {}
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    persistentVolumeClaimRetentionPolicy:
      enabled: false
      whenDeleted: Retain
      whenScaled: Retain
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests:
        cpu: 250m
        memory: 256Mi
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      extraPorts: []
      headless:
        annotations: {}
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        postgresql: ""
      ports:
        postgresql: 5432
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  replication:
    applicationName: my_application
    numSynchronousReplicas: 0
    synchronousCommit: "off"
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: false
    name: ""
  serviceBindings:
    enabled: false
  shmVolume:
    enabled: true
    sizeLimit: ""
  tls:
    autoGenerated: false
    certCAFilename: ""
    certFilename: ""
    certKeyFilename: ""
    certificatesSecret: ""
    crlFilename: ""
    enabled: false
    preferServerCiphers: true
  volumePermissions:
    containerSecurityContext:
      runAsGroup: 0
      runAsNonRoot: false
      runAsUser: 0
      seccompProfile:
        type: RuntimeDefault
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/os-shell
      tag: 11-debian-11-r77
    resources:
      limits: {}
      requests: {}
operate:
  affinity: {}
  command: []
  configMap:
    defaultMode: 484
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: /operate
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env: []
  envFrom: []
  extraConfiguration: {}
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/operate
    tag: 8.5.4
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-operate
  initContainers: []
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/liveness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  logging:
    level:
      ROOT: INFO
      io.camunda.operate: INFO
  metrics:
    prometheus: /actuator/prometheus
  nodeSelector: {}
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 600m
      memory: 400Mi
  retention:
    enabled: false
    minimumAge: 30d
  service:
    annotations: {}
    port: 80
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
optimize:
  affinity: {}
  command: []
  configMap:
    defaultMode: 492
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: /optimize
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env: []
  envFrom: []
  extraConfiguration: {}
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/optimize
    tag: 8.5.3
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-optimize
  initContainers: []
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /api/readyz
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  metrics:
    prometheus: /actuator/prometheus
  migration:
    enabled: true
    env: []
    resources:
      limits:
        cpu: 2000m
        memory: 2Gi
      requests:
        cpu: 600m
        memory: 1Gi
  nodeSelector: {}
  partitionCount: "3"
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /api/readyz
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 600m
      memory: 1Gi
  service:
    annotations: {}
    managementPort: 8092
    port: 80
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /api/readyz
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy:
    type: Recreate
  tolerations: []
postgresql:
  architecture: standalone
  audit:
    clientMinMessages: error
    logConnections: false
    logDisconnections: false
    logHostname: false
    logLinePrefix: ""
    logTimezone: ""
    pgAuditLog: ""
    pgAuditLogCatalog: "off"
  auth:
    database: web-modeler
    enablePostgresUser: true
    existingSecret: ""
    password: ""
    postgresPassword: ""
    replicationPassword: ""
    replicationUsername: repl_user
    secretKeys:
      adminPasswordKey: postgres-password
      replicationPasswordKey: replication-password
      userPasswordKey: password
    usePasswordFiles: false
    username: web-modeler
  clusterDomain: cluster.local
  common:
    exampleValue: common-chart
    global:
      annotations: {}
      createReleaseInfo: true
      elasticsearch:
        auth: {}
        clusterName: elasticsearch
        disableExporter: false
        enabled: true
        external: false
        prefix: zeebe-record
        tls:
          enabled: false
        url:
          host: '{{ .Release.Name }}-elasticsearch'
          port: 9200
          protocol: http
      identity:
        auth:
          connectors:
            clientId: connectors
          console:
            audience: console-api
            clientId: console
            redirectUrl: http://localhost:8080
            wellKnown: https://well-known-uri
          enabled: true
          identity:
            audience: camunda-identity-resource-server
            clientId: identity
            initialClaimName: oid
            redirectUrl: http://localhost:8085
          issuer: ""
          issuerBackendUrl: ""
          jwksUrl: ""
          operate:
            audience: operate-api
            clientId: operate
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/operate
          optimize:
            audience: optimize-api
            clientId: optimize
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/optimize
          publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
          tasklist:
            audience: tasklist-api
            clientId: tasklist
            existingSecret: null
            redirectUrl: https://camunda.oreedo.co/tasklist
          tokenUrl: ""
          type: KEYCLOAK
          webModeler:
            clientApiAudience: web-modeler-api
            clientId: web-modeler
            publicApiAudience: web-modeler-public-api
            redirectUrl: http://localhost:8084
          zeebe:
            audience: zeebe-api
            clientId: zeebe
        keycloak:
          auth: {}
          contextPath: /auth
          internal: false
          realm: /realms/camunda-platform
          url: {}
        service: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: ""
        tag: null
      imagePullSecrets: []
      imageRegistry: ""
      ingress:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: public
        enabled: true
        host: camunda.oreedo.co
        pathType: Prefix
        tls:
          enabled: true
          secretName: oreedo-co-tls
      labels:
        app: camunda-platform
      multiregion:
        installationType: normal
        regionId: 0
        regions: 1
      multitenancy:
        enabled: false
      opensearch:
        auth: {}
        aws:
          enabled: false
        enabled: false
        tls:
          enabled: false
        url:
          port: 443
          protocol: https
      postgresql:
        auth:
          database: ""
          existingSecret: ""
          password: ""
          postgresPassword: ""
          secretKeys:
            adminPasswordKey: ""
            replicationPasswordKey: ""
            userPasswordKey: ""
          username: ""
        service:
          ports:
            postgresql: ""
      storageClass: ""
      testDeprecationFlags:
        existingSecretsMustBeSet: ignore
      zeebeClusterName: '{{ .Release.Name }}-zeebe'
  commonAnnotations: {}
  commonLabels: {}
  containerPorts:
    postgresql: 5432
  diagnosticMode:
    args:
    - infinity
    command:
    - sleep
    enabled: false
  enabled: false
  extraDeploy: []
  fullnameOverride: ""
  global:
    annotations: {}
    createReleaseInfo: true
    elasticsearch:
      auth: {}
      clusterName: elasticsearch
      disableExporter: false
      enabled: true
      external: false
      prefix: zeebe-record
      tls:
        enabled: false
      url:
        host: '{{ .Release.Name }}-elasticsearch'
        port: 9200
        protocol: http
    identity:
      auth:
        connectors:
          clientId: connectors
        console:
          audience: console-api
          clientId: console
          redirectUrl: http://localhost:8080
          wellKnown: https://well-known-uri
        enabled: true
        identity:
          audience: camunda-identity-resource-server
          clientId: identity
          initialClaimName: oid
          redirectUrl: http://localhost:8085
        issuer: ""
        issuerBackendUrl: ""
        jwksUrl: ""
        operate:
          audience: operate-api
          clientId: operate
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/operate
        optimize:
          audience: optimize-api
          clientId: optimize
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/optimize
        publicIssuerUrl: https://camunda.oreedo.co/auth/realms/camunda-platform
        tasklist:
          audience: tasklist-api
          clientId: tasklist
          existingSecret: null
          redirectUrl: https://camunda.oreedo.co/tasklist
        tokenUrl: ""
        type: KEYCLOAK
        webModeler:
          clientApiAudience: web-modeler-api
          clientId: web-modeler
          publicApiAudience: web-modeler-public-api
          redirectUrl: http://localhost:8084
        zeebe:
          audience: zeebe-api
          clientId: zeebe
      keycloak:
        auth: {}
        contextPath: /auth
        internal: false
        realm: /realms/camunda-platform
        url: {}
      service: {}
    image:
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: ""
      tag: null
    imagePullSecrets: []
    imageRegistry: ""
    ingress:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      host: camunda.oreedo.co
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    labels:
      app: camunda-platform
    multiregion:
      installationType: normal
      regionId: 0
      regions: 1
    multitenancy:
      enabled: false
    opensearch:
      auth: {}
      aws:
        enabled: false
      enabled: false
      tls:
        enabled: false
      url:
        port: 443
        protocol: https
    postgresql:
      auth:
        database: ""
        existingSecret: ""
        password: ""
        postgresPassword: ""
        secretKeys:
          adminPasswordKey: ""
          replicationPasswordKey: ""
          userPasswordKey: ""
        username: ""
      service:
        ports:
          postgresql: ""
    storageClass: ""
    testDeprecationFlags:
      existingSecretsMustBeSet: ignore
    zeebeClusterName: '{{ .Release.Name }}-zeebe'
  image:
    debug: false
    digest: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    registry: docker.io
    repository: bitnami/postgresql
    tag: 14.12.0
  kubeVersion: ""
  ldap:
    basedn: ""
    binddn: ""
    bindpw: ""
    enabled: false
    port: ""
    prefix: ""
    scheme: ""
    searchAttribute: ""
    searchFilter: ""
    server: ""
    suffix: ""
    tls:
      enabled: false
    uri: ""
  metrics:
    containerPorts:
      metrics: 9187
    containerSecurityContext:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1001
    customLivenessProbe: {}
    customMetrics: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: false
    extraEnvVars: []
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgres-exporter
      tag: 0.15.0-debian-12-r33
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    prometheusRule:
      enabled: false
      labels: {}
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    resources:
      limits: {}
      requests: {}
    service:
      annotations:
        prometheus.io/port: '{{ .Values.metrics.service.ports.metrics }}'
        prometheus.io/scrape: "true"
      clusterIP: ""
      ports:
        metrics: 9187
      sessionAffinity: None
    serviceMonitor:
      enabled: false
      honorLabels: false
      interval: ""
      jobLabel: ""
      labels: {}
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scrapeTimeout: ""
      selector: {}
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 10
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
  nameOverride: postgresql-web-modeler
  networkPolicy:
    egressRules:
      customRules: {}
      denyConnectionsToExternal: false
    enabled: false
    ingressRules:
      primaryAccessOnlyFrom:
        customRules: {}
        enabled: false
        namespaceSelector: {}
        podSelector: {}
      readReplicasAccessOnlyFrom:
        customRules: {}
        enabled: false
        namespaceSelector: {}
        podSelector: {}
    metrics:
      enabled: false
      namespaceSelector: {}
      podSelector: {}
  postgresqlDataDir: /bitnami/postgresql/data
  postgresqlSharedPreloadLibraries: pgaudit
  primary:
    affinity: {}
    annotations: {}
    args: []
    command: []
    configuration: ""
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      enabled: true
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    existingConfigmap: ""
    existingExtendedConfigmap: ""
    extendedConfiguration: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraPodSpec: {}
    extraVolumeMounts:
    - mountPath: /tmp
      name: tmp
    - mountPath: /opt/bitnami/postgresql/conf
      name: config
    - mountPath: /opt/bitnami/postgresql/tmp
      name: postgresql-tmp
    extraVolumes:
    - emptyDir: {}
      name: tmp
    - emptyDir: {}
      name: config
    - emptyDir: {}
      name: postgresql-tmp
    hostAliases: []
    hostIPC: false
    hostNetwork: false
    initContainers: []
    initdb:
      args: ""
      password: ""
      postgresqlWalDir: ""
      scripts: {}
      scriptsConfigMap: ""
      scriptsSecret: ""
      user: ""
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    name: primary
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataSource: {}
      enabled: true
      existingClaim: ""
      labels: {}
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    pgHbaConfiguration: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
      runAsNonRoot: true
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    resources:
      limits: {}
      requests:
        cpu: 250m
        memory: 256Mi
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      extraPorts: []
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        postgresql: ""
      ports:
        postgresql: 5432
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    sidecars: []
    standby:
      enabled: false
      primaryHost: ""
      primaryPort: ""
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  psp:
    create: false
  rbac:
    create: false
    rules: []
  readReplicas:
    affinity: {}
    annotations: {}
    args: []
    command: []
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    extendedConfiguration: ""
    extraEnvVars: []
    extraEnvVarsCM: ""
    extraEnvVarsSecret: ""
    extraPodSpec: {}
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    hostIPC: false
    hostNetwork: false
    initContainers: []
    labels: {}
    lifecycleHooks: {}
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    name: read
    nodeAffinityPreset:
      key: ""
      type: ""
      values: []
    nodeSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      dataSource: {}
      enabled: true
      existingClaim: ""
      labels: {}
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      storageClass: ""
      subPath: ""
    podAffinityPreset: ""
    podAnnotations: {}
    podAntiAffinityPreset: soft
    podLabels: {}
    podSecurityContext:
      enabled: true
      fsGroup: 1001
    priorityClassName: ""
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replicaCount: 1
    resources:
      limits: {}
      requests:
        cpu: 250m
        memory: 256Mi
    schedulerName: ""
    service:
      annotations: {}
      clusterIP: ""
      externalTrafficPolicy: Cluster
      extraPorts: []
      loadBalancerIP: ""
      loadBalancerSourceRanges: []
      nodePorts:
        postgresql: ""
      ports:
        postgresql: 5432
      sessionAffinity: None
      sessionAffinityConfig: {}
      type: ClusterIP
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 15
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 1
    terminationGracePeriodSeconds: ""
    tolerations: []
    topologySpreadConstraints: []
    updateStrategy:
      rollingUpdate: {}
      type: RollingUpdate
  replication:
    applicationName: my_application
    numSynchronousReplicas: 0
    synchronousCommit: "off"
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: true
    create: false
    name: ""
  shmVolume:
    enabled: true
    sizeLimit: ""
  tls:
    autoGenerated: false
    certCAFilename: ""
    certFilename: ""
    certKeyFilename: ""
    certificatesSecret: ""
    crlFilename: ""
    enabled: false
    preferServerCiphers: true
  volumePermissions:
    containerSecurityContext:
      runAsUser: 0
    enabled: false
    image:
      digest: ""
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/bitnami-shell
      tag: 11-debian-11-r136
    resources:
      limits: {}
      requests: {}
prometheusServiceMonitor:
  enabled: false
  labels:
    release: metrics
  scrapeInterval: 10s
tasklist:
  affinity: {}
  command: []
  configMap:
    defaultMode: 484
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: /tasklist
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env: []
  envFrom: []
  extraConfiguration: {}
  extraVolumeMounts: []
  extraVolumes: []
  identity:
    userAccessRestrictions:
      enabled: true
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/tasklist
    tag: 8.5.3
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    host: ""
    path: /
    pathType: Prefix
    tls:
      enabled: false
      secretName: camunda-platform-tasklist
  initContainers: []
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/liveness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  metrics:
    prometheus: /actuator/prometheus
  nodeSelector: {}
  podAnnotations: {}
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  resources:
    limits:
      cpu: 1000m
      memory: 2Gi
    requests:
      cpu: 400m
      memory: 1Gi
  retention:
    enabled: false
    minimumAge: 30d
  service:
    annotations: {}
    port: 80
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
webModeler:
  contextPath: ""
  enabled: false
  fullnameOverride: ""
  image:
    pullSecrets: []
    registry: registry.camunda.cloud
    tag: 8.5.5
  ingress:
    annotations:
      ingress.kubernetes.io/rewrite-target: /
      nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
    className: nginx
    enabled: false
    webapp:
      host: ""
      pathType: Prefix
      tls:
        enabled: false
        secretName: camunda-platform-webmodeler-webapp
    websockets:
      host: ""
      pathType: Prefix
      tls:
        enabled: false
        secretName: camunda-platform-webmodeler-websockets
  nameOverride: ""
  restapi:
    affinity: {}
    command: []
    configuration: ""
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    dnsConfig: {}
    dnsPolicy: ""
    env: []
    envFrom: []
    externalDatabase:
      existingSecret: null
      existingSecretPasswordKey: ""
      password: ""
      url: ""
      user: ""
    extraConfiguration: {}
    extraVolumeMounts: []
    extraVolumes: []
    image:
      repository: web-modeler-ee/modeler-restapi
    initContainers: []
    livenessProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 30
      periodSeconds: 30
      probePath: /health/liveness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    mail:
      existingSecret: null
      existingSecretPasswordKey: ""
      fromAddress: ""
      fromName: Camunda 8
      smtpHost: ""
      smtpPassword: ""
      smtpPort: 587
      smtpTlsEnabled: true
      smtpUser: ""
    metrics:
      prometheus: /metrics
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      fsGroup: 1001
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 30
      periodSeconds: 30
      probePath: /health/readiness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
      requests:
        cpu: 500m
        memory: 1Gi
    service:
      annotations: {}
      managementPort: 8091
      port: 80
      type: ClusterIP
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 30
      periodSeconds: 30
      probePath: /health/liveness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    strategy: {}
    tolerations: []
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  webapp:
    affinity: {}
    command: []
    configuration: ""
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    dnsConfig: {}
    dnsPolicy: ""
    env: []
    envFrom: []
    extraConfiguration: {}
    extraVolumeMounts: []
    extraVolumes: []
    image:
      repository: web-modeler-ee/modeler-webapp
    initContainers: []
    livenessProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 15
      periodSeconds: 30
      probePath: /health/liveness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    metrics:
      prometheus: /metrics
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      fsGroup: 1001
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 15
      periodSeconds: 30
      probePath: /health/readiness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits:
        cpu: 800m
        memory: 512Mi
      requests:
        cpu: 400m
        memory: 256Mi
    service:
      annotations: {}
      managementPort: 8071
      port: 80
      type: ClusterIP
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 15
      periodSeconds: 30
      probePath: /health/liveness
      scheme: HTTP
      successThreshold: 1
      timeoutSeconds: 1
    strategy: {}
    tolerations: []
  websockets:
    affinity: {}
    command: []
    configuration: ""
    containerSecurityContext:
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
      seccompProfile:
        type: RuntimeDefault
    dnsConfig: {}
    dnsPolicy: ""
    env: []
    envFrom: []
    extraConfiguration: {}
    extraVolumeMounts: []
    extraVolumes: []
    image:
      repository: web-modeler-ee/modeler-websockets
    initContainers: []
    livenessProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 1
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    podSecurityContext:
      fsGroup: 1001
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault
    publicHost: localhost
    publicPort: 8085
    readinessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 1
    resources:
      limits:
        cpu: 200m
        memory: 128Mi
      requests:
        cpu: 100m
        memory: 64Mi
    service:
      annotations: {}
      port: 80
      type: ClusterIP
    sidecars: []
    startupProbe:
      enabled: false
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 30
      successThreshold: 1
      timeoutSeconds: 1
    strategy: {}
    tolerations: []
zeebe:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/component
            operator: In
            values:
            - zeebe-broker
        topologyKey: kubernetes.io/hostname
  clusterSize: 1
  command: []
  configMap:
    defaultMode: 492
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  cpuThreadCount: "3"
  debug: false
  dnsConfig: {}
  dnsPolicy: ""
  enabled: true
  env:
  - name: ZEEBE_BROKER_DATA_SNAPSHOTPERIOD
    value: 5m
  - name: ZEEBE_BROKER_DATA_DISK_FREESPACE_REPLICATION
    value: 2GB
  - name: ZEEBE_BROKER_DATA_DISK_FREESPACE_PROCESSING
    value: 3GB
  envFrom: []
  extraConfiguration: {}
  extraInitContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/zeebe
    tag: 8.5.4
  initContainers: []
  ioThreadCount: "3"
  javaOpts: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/zeebe/data
    -XX:ErrorFile=/usr/local/zeebe/data/zeebe_error%p.log -XX:+ExitOnOutOfMemoryError
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  log4j2: ""
  logLevel: info
  metrics:
    prometheus: /actuator/prometheus
  nodeSelector: {}
  partitionCount: 1
  persistenceType: disk
  podAnnotations: {}
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
    minAvailable: null
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  priorityClassName: ""
  pvcAccessModes:
  - ReadWriteOnce
  pvcAnnotations: {}
  pvcSize: 10Gi
  pvcStorageClassName: ""
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  replicationFactor: 1
  resources:
    limits:
      cpu: 960m
      memory: 1920Mi
    requests:
      cpu: 800m
      memory: 1200Mi
  retention:
    enabled: false
    minimumAge: 30d
    policyName: zeebe-record-retention-policy
  service:
    annotations: {}
    commandName: command
    commandPort: 26501
    extraPorts: []
    httpName: http
    httpPort: 9600
    internalName: internal
    internalPort: 26502
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/startup
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy:
    type: RollingUpdate
  tolerations: []
zeebeGateway:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/component
            operator: In
            values:
            - zeebe-gateway
        topologyKey: kubernetes.io/hostname
  command: []
  configMap:
    defaultMode: 484
  configuration: ""
  containerSecurityContext:
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1001
    seccompProfile:
      type: RuntimeDefault
  contextPath: ""
  dnsConfig: {}
  dnsPolicy: ""
  env: []
  envFrom: []
  extraConfiguration: {}
  extraInitContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  image:
    pullSecrets: []
    registry: ""
    repository: camunda/zeebe
    tag: 8.5.4
  ingress:
    className: public
    enabled: true
    grpc:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/backend-protocol: GRPC
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: public
      enabled: true
      grpc:
        annotations:
          ingress.kubernetes.io/rewrite-target: /
          nginx.ingress.kubernetes.io/backend-protocol: GRPC
          nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
          nginx.ingress.kubernetes.io/ssl-redirect: "false"
        className: nginx
        enabled: false
        host: ""
        path: /
        pathType: Prefix
        tls:
          enabled: false
          secretName: camunda-platform-zeebe-gateway-grpc
      host: zeebe.oreedo.co
      path: /
      pathType: Prefix
      tls:
        enabled: true
        secretName: oreedo-co-tls
    host: zeebe.oreedo.co
    rest:
      annotations:
        ingress.kubernetes.io/rewrite-target: /
        nginx.ingress.kubernetes.io/backend-protocol: HTTP
        nginx.ingress.kubernetes.io/proxy-buffer-size: 128k
        nginx.ingress.kubernetes.io/ssl-redirect: "false"
      className: nginx
      enabled: false
      host: ""
      path: /
      pathType: Prefix
      tls:
        enabled: false
        secretName: camunda-platform-zeebe-gateway-rest
    tls:
      enabled: true
      secretName: oreedo-co-tls
  initContainers: []
  javaOpts: -XX:+ExitOnOutOfMemoryError
  livenessProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/liveness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  log4j2: ""
  logLevel: info
  metrics:
    prometheus: /actuator/prometheus
  nodeSelector: {}
  podAnnotations: {}
  podDisruptionBudget:
    enabled: false
    maxUnavailable: null
    minAvailable: 1
  podLabels: {}
  podSecurityContext:
    fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  priorityClassName: ""
  readinessProbe:
    enabled: true
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/readiness
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  replicas: 1
  resources:
    limits:
      cpu: 400m
      memory: 450Mi
    requests:
      cpu: 400m
      memory: 450Mi
  service:
    annotations: {}
    grpcName: gateway
    grpcPort: 26500
    httpName: http
    httpPort: 9600
    internalName: internal
    internalPort: 26502
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    restName: rest
    restPort: 8080
    type: ClusterIP
  serviceAccount:
    annotations: {}
    automountServiceAccountToken: false
    enabled: true
    name: ""
  sidecars: []
  startupProbe:
    enabled: false
    failureThreshold: 5
    initialDelaySeconds: 30
    periodSeconds: 30
    probePath: /actuator/health/startup
    scheme: HTTP
    successThreshold: 1
    timeoutSeconds: 1
  strategy: {}
  tolerations: []
